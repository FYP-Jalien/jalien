package alien.api;

import java.io.Closeable;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;
import java.net.Inet6Address;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.security.KeyStoreException;
import java.security.SecureRandom;
import java.security.Security;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.net.ssl.KeyManagerFactory;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLEngine;
import javax.net.ssl.SSLEngineResult;
import javax.net.ssl.SSLEngineResult.HandshakeStatus;
import javax.net.ssl.SSLEngineResult.Status;
import javax.net.ssl.SSLSession;
import javax.net.ssl.TrustManagerFactory;

import org.bouncycastle.jce.provider.BouncyCastleProvider;

import alien.config.ConfigUtils;
import alien.log.RequestEvent;
import alien.monitoring.CacheMonitor;
import alien.monitoring.Monitor;
import alien.monitoring.MonitorFactory;
import alien.monitoring.Timing;
import alien.shell.ErrNo;
import alien.user.AliEnPrincipal;
import alien.user.JAKeyStore;
import alien.user.UserFactory;

/**
 * @author costing
 *
 */
public class DispatchSSLServerNIO implements Runnable {

	/**
	 * Reset the object stream every this many objects sent
	 */
	private static final int RESET_OBJECT_STREAM_COUNTER = 10;

	/**
	 * Logger
	 */
	static final Logger logger = ConfigUtils.getLogger(DispatchSSLServerNIO.class.getCanonicalName());

	/**
	 * Service monitoring
	 */
	static final Monitor monitor = MonitorFactory.getMonitor(DispatchSSLServerNIO.class.getCanonicalName());

	/**
	 * Connections that need looking at
	 */
	private static BlockingQueue<Runnable> taskQueue = new LinkedBlockingQueue<>();

	/**
	 * Thread pool handling messages
	 */
	private static ThreadPoolExecutor executor = new ThreadPoolExecutor(8, 16, 1, TimeUnit.MINUTES, taskQueue);

	private static final int defaultPort = 8098;
	private static String serviceName = "apiService";

	private static boolean forwardRequest = false;

	private static AtomicInteger activeSessions = new AtomicInteger();

	private static CacheMonitor ipv6Connections = null;

	private static Selector serverSelector;

	private static ServerSocketChannel serverSocketChannel;

	private static final SSLContext sslContext = getSSLContext();

	private static ConcurrentHashMap<SelectionKey, DispatchSSLServerNIO> sessionMap = new ConcurrentHashMap<>();

	static {
		if (monitor != null) {
			monitor.addMonitoring("activeSessions", (names, values) -> {
				names.add("activeSessions");
				values.add(Double.valueOf(activeSessions.get()));

				names.add("acceptorPoolSize");
				values.add(Double.valueOf(executor.getPoolSize()));

				names.add("acceptorPoolActiveCount");
				values.add(Double.valueOf(executor.getActiveCount()));

				names.add("acceptorPoolQueueSize");
				values.add(Double.valueOf(taskQueue.size()));
			});

			ipv6Connections = monitor.getCacheMonitor("ipv6_connections");
		}
	}

	// --------------------------- Per connection information

	/**
	 * The entire connection
	 */
	private final SocketChannel channel;

	/**
	 * Getting requests by this stream
	 */
	private ObjectInputStream ois;

	/**
	 * Writing replies here
	 */
	private ObjectOutputStream oos;

	private int objectsSentCounter = 0;

	private OutputStream os;

	private X509Certificate partnerCerts[] = null;

	private SelectionKey key;

	private final SSLEngine sslEngine;

	private final ByteBuffer myNetData;
	private final ByteBuffer peerNetData;

	private PipedOutputStream pos = null;
	private PipedInputStream pis = null;

	private final AtomicBoolean isActive = new AtomicBoolean(false);

	private final AtomicBoolean isKilled = new AtomicBoolean(false);

	private final AliEnPrincipal remoteIdentity;

	private class ByteBufferOutputStream extends OutputStream {

		private ByteBuffer buffer = ByteBuffer.allocate(8192);

		@Override
		public void write(int arg0) throws IOException {
			if (buffer.remaining() <= 0)
				flush();

			buffer.put((byte) (arg0 & 0xFF));
		}

		@Override
		public void flush() throws IOException {
			System.err.println("Flush called");

			ByteBuffer netOutput = ByteBuffer.allocate(sslEngine.getSession().getPacketBufferSize());

			buffer.flip();

			SSLEngineResult sslResult = sslEngine.wrap(buffer, netOutput);

			System.err.println("Wrap result: " + sslResult.getStatus().name());

			if (sslResult.getStatus() == Status.OK) {
				if (sslResult.getHandshakeStatus() == HandshakeStatus.NEED_TASK)
					tasks(sslEngine);
			}

			netOutput.flip();
			channel.write(netOutput);

			buffer.clear();
		}
	}

	private static HandshakeStatus tasks(SSLEngine sslEngine) {
		Runnable r;
		while ((r = sslEngine.getDelegatedTask()) != null) {
			System.err.println("Running a fg task " + r);
			r.run();
		}

		System.err.println("Done need task");

		return sslEngine.getHandshakeStatus();
	}

	/**
	 * @param channel
	 * @throws Exception
	 */
	public DispatchSSLServerNIO(final SocketChannel channel) throws Exception {
		System.err.println("Creating DO");

		InetSocketAddress addr = (InetSocketAddress) channel.getRemoteAddress();

		sslEngine = sslContext.createSSLEngine(addr.getAddress().getHostAddress(), addr.getPort());

		sslEngine.setUseClientMode(false);

		sslEngine.setNeedClientAuth(true);

		this.channel = channel;

		channel.configureBlocking(false);

		// System.err.println("Session app buffer size: " + session.getApplicationBufferSize());
		// System.err.println("Session packet buffer size: " + session.getPacketBufferSize());

		final SSLSession session = sslEngine.getSession();

		myNetData = ByteBuffer.allocate(session.getPacketBufferSize());
		peerNetData = ByteBuffer.allocate(session.getPacketBufferSize());

		pos = new PipedOutputStream();
		pis = new PipedInputStream(pos, 1024 * 1024);

		if (!doHandshake(channel, sslEngine, myNetData, peerNetData))
			throw new IOException("Handshake failed, dropping this connection");

		System.err.println("Handshake complete, now I can go ahead with the selection");

		partnerCerts = (X509Certificate[]) sslEngine.getSession().getPeerCertificates();

		if (logger.isLoggable(Level.FINE))
			logger.log(Level.FINE, getClientInfo(partnerCerts[0]));

		remoteIdentity = UserFactory.getByCertificate(partnerCerts);

		if (remoteIdentity == null)
			throw new IOException("Could not get the identity of this certificate chain: " + Arrays.toString(partnerCerts));

		remoteIdentity.setRemoteEndpoint(((InetSocketAddress) channel.getRemoteAddress()).getAddress());

		if (remoteIdentity.getRemoteEndpoint() instanceof Inet6Address)
			ipv6Connections.incrementHits();
		else
			ipv6Connections.incrementMisses();

		try (RequestEvent event = new RequestEvent(DispatchSSLServer.getAccessLog())) {
			event.command = "login";
			event.identity = remoteIdentity;

			event.arguments = new ArrayList<>();

			for (final X509Certificate cert : partnerCerts)
				event.arguments.add(cert.getSubjectX500Principal().getName() + " (expires " + cert.getNotAfter() + ")");
		}
		catch (@SuppressWarnings("unused") final IOException ioe) {
			// ignore any exception in writing out the event
		}

		key = channel.register(serverSelector, SelectionKey.OP_READ);

		serverSelector.wakeup();

		os = new ByteBufferOutputStream();

		oos = new ObjectOutputStream(os);
	}

	private void notifyData() throws IOException {
		// System.err.println("Handling data notification");

		if (isKilled.get())
			return;

		// boolean anyDataToProcess = false;

		ByteBuffer smallBuffer = ByteBuffer.allocate(512);
		peerNetData.flip();

		while (true) {
			smallBuffer.clear();
			int num = channel.read(smallBuffer);

			System.err.println("  got data notification for " + num + " bytes");

			if (num == -1) {
				cleanup();
				// break;
			}
			else if (num == 0) {
				// No bytes read; try again later ...
				break;
			}
			else {
				// Process incoming data
				// logBuffer(peerNetData);

				peerNetData.position(peerNetData.limit());
				peerNetData.limit(peerNetData.capacity());

				// System.err.println("I'm at " + peerNetData.position() + " / " + peerNetData.limit());

				smallBuffer.flip();
				peerNetData.put(smallBuffer);

				peerNetData.flip();

				myNetData.clear();

				SSLEngineResult res = sslEngine.unwrap(peerNetData, myNetData);

				System.err.println(" decoding status: " + res.getStatus().name());

				if (res.getStatus() == SSLEngineResult.Status.OK) {
					peerNetData.compact();
					peerNetData.flip();

					if (myNetData.hasRemaining()) {
						// String s = new String(myNetData.array(), 0, myNetData.position());
						System.err.println("    decoded data: " + myNetData.position() + " bytes");

						if (myNetData.position() > 0) {
							newDataBlock(Arrays.copyOfRange(myNetData.array(), 0, myNetData.position()));

							// anyDataToProcess = true;
						}

						// myNetData.flip();
					}
				}
				else if (res.getStatus() == SSLEngineResult.Status.CLOSED)
					cleanup();
				else {
					System.err.println("Unhandled processing result: " + res.getStatus().name());
				}
			}
		}
	}

	private void newDataBlock(final byte[] buffer) {
		try {
			pos.write(buffer);
			// System.err.println("Buffer size is " + pis.available());

			if (isActive.compareAndSet(false, true)) {
				System.err.println("Starting background reader");
				executor.submit(this);
			}
			else
				pos.flush();
		}
		catch (final IOException ioe) {
			// buffer overflow, the sent object was too large
			logger.log(Level.WARNING, "Exception handling a new data block, closing connection", ioe);
			cleanup();
		}
	}

	/**
	 *
	 */
	private void cleanup() {
		System.err.println("Cleaning up " + key);

		DispatchSSLServerNIO removed = sessionMap.remove(key);

		if (removed != null) {
			System.err.println("  no object was removed from map");
			System.err.println("Map content:\n" + sessionMap);
		}

		key.interestOps(0);
		key.cancel();

		close(channel);
		close(pos);
		close(pis);
		close(ois);

		isKilled.set(true);
	}

	private static boolean doHandshake(SocketChannel socketChannel, SSLEngine engine, ByteBuffer myNetData, ByteBuffer peerNetData) throws Exception {
		// Create byte buffers to use for holding application data
		int appBufferSize = engine.getSession().getApplicationBufferSize();
		ByteBuffer myAppData = ByteBuffer.allocate(appBufferSize);
		ByteBuffer peerAppData = ByteBuffer.allocate(appBufferSize);

		// Begin handshake
		engine.beginHandshake();
		SSLEngineResult.HandshakeStatus hs = engine.getHandshakeStatus();

		// Process handshaking message
		while (hs != SSLEngineResult.HandshakeStatus.FINISHED && hs != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {
			// System.err.println("State = " + hs.name());
			switch (hs) {
				case NEED_UNWRAP:
					// Receive handshaking data from peer
					if (socketChannel.read(peerNetData) < 0) {
						return false;
					}

					// Process incoming handshaking data
					peerNetData.flip();
					SSLEngineResult res = engine.unwrap(peerNetData, peerAppData);
					peerNetData.compact();
					hs = res.getHandshakeStatus();

					break;

				case NEED_WRAP:
					// Empty the local network packet buffer.
					myNetData.clear();

					// Generate handshaking data
					res = engine.wrap(myAppData, myNetData);
					hs = res.getHandshakeStatus();

					// Check status
					switch (res.getStatus()) {
						case OK:
							myNetData.flip();

							// Send the handshaking data to peer
							while (myNetData.hasRemaining()) {
								if (socketChannel.write(myNetData) < 0)
									return false;
							}

							break;
						default:
							System.err.println("Unhandled handshake wrap status code: " + res.getStatus());
					}
					break;

				case NEED_TASK:
					hs = tasks(engine);

					break;

				default:
					System.err.println("Unhandled handshake status code: " + hs);
			}
		}

		return true;
	}

	private double executeOneRequest(final Object o) throws Exception {
		double ret = -1;

		if (o instanceof Request) {
			Request r = (Request) o;

			r.setPartnerIdentity(remoteIdentity);

			r.setPartnerCertificate(partnerCerts);

			final double requestProcessingDuration;

			try (RequestEvent event = new RequestEvent(DispatchSSLServer.getAccessLog())) {
				event.clientAddress = remoteIdentity.getRemoteEndpoint();
				event.clientPort = remoteIdentity.getRemotePort();
				event.command = r.getClass().getSimpleName();
				event.clientID = r.getVMUUID();
				event.requestId = r.getRequestID();
				event.arguments = r.getArguments();

				try {
					r = Dispatcher.execute(r, forwardRequest);
					event.exitCode = 0;
				}
				catch (final Exception e) {
					logger.log(Level.WARNING, "Returning an exception to the client", e);

					r.setException(new ServerException(e.getMessage(), e));

					event.exception = e;
					event.exitCode = ErrNo.EBADE.getErrorCode();
					event.errorMessage = "Exception executing request";
				}

				event.identity = r.getEffectiveRequester();

				requestProcessingDuration = event.timing.getMillis();
			}

			ret = requestProcessingDuration;

			final double serializationTime;

			try (Timing timing = new Timing()) {
				// System.err.println("When returning the object, ex is "+r.getException());

				oos.writeObject(r);

				if (++objectsSentCounter >= RESET_OBJECT_STREAM_COUNTER) {
					oos.reset();
					objectsSentCounter = 0;
				}

				oos.flush();

				serializationTime = timing.getMillis();
			}

			lSerialization += serializationTime;

			logger.log(Level.INFO, "Got request from " + r.getRequesterIdentity() + " : " + r.getClass().getCanonicalName());

			if (monitor != null) {
				monitor.addMeasurement("request_processing", requestProcessingDuration);
				monitor.addMeasurement("serialization", serializationTime);
			}
		}
		else
			logger.log(Level.WARNING, "I don't know what to do with an object of type " + o.getClass().getCanonicalName());

		return ret;
	}

	@Override
	public void run() {
		try {
			if (ois == null)
				try {
					ois = new ObjectInputStream(pis);
					System.err.println("ois created");
				}
				catch (IOException e) {
					System.err.println("Cannot create the ois: " + e.getMessage());
					return;
				}

			try {
				System.err.println("Checking if there is any data on the pipe");
				while (pis.available() > 0) {
					System.err.println("Available size: " + pis.available() + ", blocking for reading");
					final Object o = ois.readObject();

					if (o != null) {
						try {
							final double duration = executeOneRequest(o);

							if (duration >= 0) {
								// TODO: handle a successfully executed object
							}
						}
						catch (final Exception e) {
							logger.log(Level.WARNING, "Exception running a command", e);
							cleanup();
						}
					}
				}
				System.err.println("No data left on the pipe, exiting for now");
			}
			catch (ClassNotFoundException e) {
				logger.log(Level.SEVERE, "Cannot deserialize a request", e);
			}
			catch (IOException e) {
				logger.log(Level.SEVERE, "IOException running a request", e);
			}
		}
		finally {
			isActive.set(false);
		}
	}

	private static void close(final Closeable c) {
		try {
			if (c != null)
				c.close();
		}
		catch (@SuppressWarnings("unused") final IOException ioe) {
			// ignore
		}
	}

	void flush() throws IOException {
		oos.flush();
	}

	private static boolean isHostCertValid() {
		try {
			((java.security.cert.X509Certificate) JAKeyStore.getKeyStore().getCertificateChain("User.cert")[0]).checkValidity();
		}
		catch (@SuppressWarnings("unused") final CertificateException | KeyStoreException e) {
			return false;
		}

		return true;
	}

	private static void handleNewConnection(final SocketChannel sc) {
		try {
			System.err.println("New connection notification");

			final DispatchSSLServerNIO connectionWrapper = new DispatchSSLServerNIO(sc);

			sessionMap.put(connectionWrapper.key, connectionWrapper);

			// initialize the object stream on the other side
			connectionWrapper.flush();
		}
		catch (final Throwable e) {
			logger.log(Level.SEVERE, "Error handling new socket", e);
		}
	}

	private static Thread acceptorThread = new Thread() {
		@Override
		public void run() {
			System.err.println("Acceptor thread ready");

			while (true) {
				try {
					@SuppressWarnings("resource")
					final SocketChannel sc = serverSocketChannel.accept();

					executor.submit(() -> handleNewConnection(sc));
				}
				catch (final IOException ioe) {
					System.err.println("Exception handling a new socket: " + ioe.getMessage());
				}
			}
		}
	};

	private static Thread selectorThread = new Thread() {
		@Override
		public void run() {
			System.err.println("Selector thread active");

			while (true) {
				try {
					serverSelector.select();

					var selectedKeys = serverSelector.selectedKeys();

					var it = selectedKeys.iterator();

					while (it.hasNext()) {
						final SelectionKey key = it.next();

						if (key == null || !key.isValid()) {
							System.err.println("Detected closed key, disposing of it");
							it.remove();
							continue;
						}

						if (key.isReadable()) {
							final DispatchSSLServerNIO obj = sessionMap.get(key);

							if (obj != null) {
								// System.err.println("Key found in session map: " + key);
								// System.err.println("Map content: " + sessionMap);
								// disable future events until the dispatcher has digested the data
								// key.interestOps(0);
								// System.err.println("Notifying of new data");
								obj.notifyData();
							}
							else {
								System.err.println("Didn't find a corresponding session");
							}
						}

						it.remove();
					}
				}
				catch (final IOException ioe) {
					System.err.println("Server selector threw an exception : " + ioe.getMessage());
					ioe.printStackTrace();
				}
			}
		}
	};

	private static SSLContext getSSLContext() {
		try {
			java.lang.System.setProperty("jdk.tls.client.protocols", "TLSv1.2,TLSv1.3");

			Security.addProvider(new BouncyCastleProvider());

			final KeyManagerFactory kmf = KeyManagerFactory.getInstance("SunX509", "SunJSSE");

			kmf.init(JAKeyStore.getKeyStore(), JAKeyStore.pass);

			final SSLContext sc = SSLContext.getInstance("TLS");

			final TrustManagerFactory tmf = TrustManagerFactory.getInstance("SunX509");
			tmf.init(JAKeyStore.getKeyStore());

			sc.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new SecureRandom());

			return sc;
		}
		catch (final Exception e) {
			e.printStackTrace();
		}

		return null;
	}

	/**
	 * @throws IOException
	 */
	@SuppressWarnings("resource")
	public static void runService() throws IOException {
		if (!isHostCertValid()) {
			logger.log(Level.SEVERE, "Host certificate is not valid!");
			return;
		}

		int port = defaultPort;

		String address = ConfigUtils.getConfig().gets(serviceName).trim();

		if (address.length() != 0) {
			final int idx = address.indexOf(':');

			if (idx >= 0)
				try {
					port = Integer.parseInt(address.substring(idx + 1).trim());
					address = address.substring(0, idx).trim();
				}
				catch (@SuppressWarnings("unused") final Exception e) {
					port = defaultPort;
				}
		}

		if (address.equals("*"))
			address = "";

		serverSelector = Selector.open();

		serverSocketChannel = ServerSocketChannel.open();
		serverSocketChannel.socket().bind(new InetSocketAddress(port));

		try {
			logger.log(Level.INFO, "Running JCentral with host cert: " + ((java.security.cert.X509Certificate) JAKeyStore.getKeyStore().getCertificateChain("User.cert")[0]).getSubjectDN());

			System.out.println("JCentral listening on " + serverSocketChannel.getLocalAddress());

			logger.log(Level.INFO, "JCentral listening on  " + serverSocketChannel.getLocalAddress());

			acceptorThread.start();

			selectorThread.start();

			while (true) {
				if (!isHostCertValid()) {
					logger.log(Level.SEVERE, "Host certificate is not valid any more, please renew it and restart the service");
					return;
				}

				Thread.sleep(60000);
			}

		}
		catch (final Throwable e) {
			logger.log(Level.SEVERE, "Could not initiate SSL Server Socket on " + address + ":" + port, e);
		}
	}

	/**
	 * Total amount of time (in milliseconds) spent in writing objects to the socket.
	 */
	public static double lSerialization = 0;

	/**
	 * Print client info on SSL partner
	 */
	private static String getClientInfo(final X509Certificate cert) {
		return "Peer Certificate Information:\n" + "- Subject: " + cert.getSubjectDN().getName() + "- Issuer: \n" + cert.getIssuerDN().getName() + "- Version: \n" + cert.getVersion()
				+ "- Start Time: \n" + cert.getNotBefore().toString() + "\n" + "- End Time: " + cert.getNotAfter().toString() + "\n" + "- Signature Algorithm: " + cert.getSigAlgName() + "\n"
				+ "- Serial Number: " + cert.getSerialNumber();
	}

	/**
	 * Print some info on the SSL Socket
	 */
	// private static String printServerSocketInfo(SSLServerSocket s) {
	// return "Server socket class: " + s.getClass()
	// + "\n Socket address = " + s.getInetAddress().toString()
	// + "\n Socket port = " + s.getLocalPort()
	// + "\n Need client authentication = " + s.getNeedClientAuth()
	// + "\n Want client authentication = " + s.getWantClientAuth()
	// + "\n Use client mode = " + s.getUseClientMode();
	// }

}